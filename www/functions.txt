#include "template.txt"
<?php

 include( '../Smarty/libs/Smarty.class.php' );
 $smarty = new Smarty;
 include( 'common.php' );

 $smarty->assign( 'lefttitle', 'example.' );
 $smarty->assign( 'leftcontent', array(
 	array( '',
	<<<ENDOFPRE

H1(Sieve 2 API: Functions)

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_support_alloc)(C_TYPE(sieve2_support_t) **C_ARG(p));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_support_free)(C_TYPE(sieve2_support_t) *C_ARG(p));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_support_register)(C_TYPE(sieve2_support_t) *C_ARG(p), C_TYPE(void) *C_ARG(thing), C_TYPE(int) C_ARG(type));
	)

The support functions are used to build up a structure which indicates
what actions and extensions are supported by the client application.
An application could potentially create several "personalities" with
different support structures, perhaps to allow an administrator to limit
certain actions, such as vacation and notification, to certain users.
In general, however, only one support structure is needed and it can
be safely shared among multiple threads of the client program.

CODE	(
NO	#define SIEVE2_MESSAGE_SIZE
BR	#define SIEVE2_MESSAGE_HEADER
BR	#define SIEVE2_MESSAGE_ENVELOPE
BR
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_message_alloc)(C_TYPE(sieve2_message_t) **C_ARG(m));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_message_free)(C_TYPE(sieve2_message_t) *C_ARG(m));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_message_register)(C_TYPE(sieve2_message_t) *C_ARG(m), C_TYPE(void) *C_ARG(thing), C_TYPE(int) C_ARG(type));
	)

P The message functions are used to build up a structure holding key information
about the message. The most important thing happening is parsing the message
header into its constituent fields. Other message details currently supported
are the size of the entire message (not just the size of the headers) and the
envelope recipient (which is may be different than the To: header field).

P There are plans to accept a pre-parsed table of headers. This will be particularly
useful for client applications which store their headers as parsed structures.
The format for this data structure is still being discussed, and in particular,
finding a relatively neutral format which is not dependant upon any third party
applications and yet is easily transformed to and from those third party structures.

CODE	(
NO	#define SIEVE2_ACTION_REDIRECT
BR	#define SIEVE2_ACTION_REJECT
BR	#define SIEVE2_ACTION_DISCARD
BR	#define SIEVE2_ACTION_FILEINTO
BR	#define SIEVE2_ACTION_KEEP
BR	#define SIEVE2_ACTION_NOTIFY
BR
BR	#define SIEVE2_ACTION_NULL
BR	#define SIEVE2_ACTION_NONE
BR	#define SIEVE2_ACTION_VACATION
BR	#define SIEVE2_ACTION_SETFLAG
BR	#define SIEVE2_ACTION_ADDFLAG
BR	#define SIEVE2_ACTION_REMOVEFLAG
BR	#define SIEVE2_ACTION_MARK
BR	#define SIEVE2_ACTION_UNMARK	
BR	#define SIEVE2_ACTION_DENOTIFY
BR
BR	#define SIEVE2_ACTION_ALL
BR
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_action_alloc)(C_TYPE(sieve2_action_t) **C_ARG(a));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_action_free)(C_TYPE(sieve2_action_t) *C_ARG(a));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_action_next)(C_TYPE(sieve2_action_t) **C_ARG(a), C_TYPE(int) *C_ARG(code), C_TYPE(void) **C_ARG(context));
	)

P The action functions are used to retrieve the results of sieve2_execute(). There
is no external registration function (there is a sort of internal one, though) but
rather a the sieve2_action_next() function which helps to step through the list of
resulting actions. The action code is placed into the variable pointed to by the
code argument and a pointed to the corresponding context structure is placed into the
variable pointed to by context. Only structures which the client application has
registered support for will be returned; in the event that this restriction
is violated, the client should not attempt to "guess" the format of the returned
structure. The returned structures should not be freed by the client; they are all
freed by sieve2_action_free().

CODE	(
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_error_alloc)(C_TYPE(sieve2_error_t) **C_ARG(e));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_error_free)(C_TYPE(sieve2_error_t) *C_ARG(e));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_error_next)(C_TYPE(sieve2_error_t) **C_ARG(e), C_TYPE(int) *C_ARG(code), C_TYPE(void) **C_ARG(context));
	)

P The error functions are used to retrieve error codes resulting from mistakes
in a script found either during validation with sieve2_validate or execution
with sieve2_execute.


CODE	(
NO	#define SIEVE2_SCRIPT_SIZE
BR	#define SIEVE2_SCRIPT_CALLBACK
BR	#define SIEVE2_SCRIPT_CHAR_ARRAY
BR	#define SIEVE2_SCRIPT_FILE_POINTER
BR	#define SIEVE2_SCRIPT_INCLUDE_CALLBACK
BR
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_script_alloc)(C_TYPE(sieve2_script_t) **C_ARG(s));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_script_free)(C_TYPE(sieve2_script_t) *C_ARG(s));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_script_register)(C_TYPE(sieve2_script_t) *C_ARG(s), C_TYPE(void) *C_ARG(thing), C_TYPE(int) C_ARG(type));
	)

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_interp_alloc)(C_TYPE(sieve2_interp_t) **C_ARG(t));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_interp_free)(C_TYPE(sieve2_interp_t) *C_ARG(t));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_interp_register)(C_TYPE(sieve2_interp_t) *C_ARG(t), C_TYPE(void) *C_ARG(thing), C_TYPE(int) C_ARG(type));
	)

Allocate an interp struct to hold parser/scanner state.
Once flex provides reentrantcy, all builds will use it.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_validate)(
BR	TAB	C_TYPE(sieve2_interp_t) *C_ARG(t), C_TYPE(sieve2_script_t) *C_ARG(s),
BR	TAB	C_TYPE(sieve2_support_t) *C_ARG(p), C_TYPE(sieve2_error_t) *C_ARG(e));
BR
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_execute)(
BR	TAB	C_TYPE(sieve2_interp_t) *C_ARG(t), C_TYPE(sieve2_script_t) *C_ARG(s),
BR	TAB	C_TYPE(sieve2_support_t) *C_ARG(p), C_TYPE(sieve2_error_t) *C_ARG(e),
BR	TAB	C_TYPE(sieve2_message_t) *C_ARG(m), C_TYPE(sieve2_action_t) *C_ARG(a));
	)

Validate a script for syntax and feature support.
Execute a script on a message, producing an action list.

CODE	(
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_extensions_listconst)(C_TYPE(char) **C_ARG(extensions));
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_extensions_listsupport)(C_TYPE(sieve2_support_t) *C_ARG(p), C_TYPE(char) **C_ARG(extensions));
	)

Get a space separated list of supported extensions.
If a sieve2_support struct is passed, only those extensions will appear.
If NULL is passed in the support argument, all extensions that the
interpreter knows about will appear. The caller must call free(extensions).

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) *C_FUNC(sieve2_errstr)(C_QUAL(const) C_TYPE(int) C_ARG(code));
	)
Convert an error code to a generic description of the error.
Detailed error reports are found in the sieve2_error array.

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) *C_FUNC(sieve2_credits)(C_TYPE(void));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) *C_FUNC(sieve2_license)(C_TYPE(void));
	)
Get a list of Credits about who writes libSieve
and a brief rundown on the License under which
libSieve is distributed.

ENDOFPRE
 	) ) );

 $smarty->assign( 'righttitle', 'notes.' );
 $smarty->assign( 'rightcontent', array(
 	array(
	<<<ENDOFPRE
The Sieve 2 API is an extensible API designed to ride through revisions
in the underlying implementation and through updates to the Sieve RFC
and various extensions, as they move from drafts towards full RFC&#39;s.

The API has three main parts: the incomplete opaque internal types, the
complete and user accessible external structures and the function calls.
ENDOFPRE
	) ) );
 $smarty->assign( 'rightlinks', array(
 	array( 'API Functions', 'functions.php' ),
 	array( 'API Structures', 'structures.php' ),
 	array( 'Usage Example 1', 'example1.php' ),
 	array( 'Usage Example 2', 'example2.php' ),
	) );

 $smarty->display( 'tweedy.tpl' );

?>
