#include "template.txt"
<?php

 include( '../Smarty/libs/Smarty.class.php' );
 $smarty = new Smarty;
 include( 'common.php' );

 $smarty->assign( 'lefttitle', 'example.' );
 $smarty->assign( 'leftcontent', array(
 	array( '',
	<<<ENDOFPRE

H1(Sieve 2 API: Functions)

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_alloc)(C_TYPE(sieve2_context_t) **C_ARG(c));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_free)(C_TYPE(sieve2_context_t) **C_ARG(c));
	)

P	Foo.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_callbacks)(C_TYPE(sieve2_context_t) *C_ARG(c), C_TYPE(sieve2_callback_t) *C_ARG(callbacks));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_listextensions)(C_TYPE(sieve2_context_t) *C_ARG(c));
	)

P	Foo.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_validate)(C_TYPE(sieve2_action_t) *C_ARG(c), C_TYPE(void) *C_ARG(user_data));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_execute)(C_TYPE(sieve2_action_t) *C_ARG(c), C_TYPE(void) *C_ARG(user_data));
	)

P	Foo.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_getvalue_int)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_getvalue_string)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) * C_QUAL(const) C_FUNC(sieve2_getvalue_stringlist)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
	)

P The error functions are used to retrieve error codes resulting from mistakes
in a script found either during validation with sieve2_validate or execution
with sieve2_execute.


CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_int)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name), C_TYPE(int) C_ARG(value));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_string)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(value));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_stringlist)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE( char) * C_QUAL(const) C_ARG(name), C_QUAL(const) C_TYPE(char) * C_QUAL(const) * C_QUAL(const) C_ARG(value));
	)

P	Foo.

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) *C_FUNC(sieve2_errstr)(C_QUAL(const) C_TYPE(int) C_ARG(code));
	)
P Convert an error code to a generic description of the error.
Detailed error reports are found in the sieve2_error array.

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_credits)(C_TYPE(void));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_license)(C_TYPE(void));
	)
P Get a list of Credits about who writes libSieve
and a brief rundown on the License under which
libSieve is distributed.

ENDOFPRE
 	) ) );

 $smarty->assign( 'righttitle', 'notes.' );
 $smarty->assign( 'rightcontent', array(
 	array(
	<<<ENDOFPRE
The Sieve 2 API is an extensible API designed to ride through revisions
in the underlying implementation and through updates to the Sieve RFC
and various extensions, as they move from drafts towards full RFC&#39;s.

The API has three main parts: the incomplete opaque internal types, the
complete and user accessible external structures and the function calls.
ENDOFPRE
	) ) );
 $smarty->assign( 'rightlinks', array(
 	array( 'API Functions', 'functions.php' ),
 	array( 'API Structures', 'structures.php' ),
 	array( 'Example App', 'example.php' ),
	) );

 $smarty->display( 'tweedy.tpl' );

?>
