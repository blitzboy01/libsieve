#include "template.txt"
<?php

 include( '../Smarty/libs/Smarty.class.php' );
 $smarty = new Smarty;
 include( 'common.php' );

 $smarty->assign( 'lefttitle', 'example.' );
 $smarty->assign( 'leftcontent', array(
 	array( '',
	<<<ENDOFPRE

H1(Sieve 2 API: Functions)

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_alloc)(C_TYPE(sieve2_context_t) **C_ARG(c));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_free)(C_TYPE(sieve2_context_t) **C_ARG(c));
	)

P	Allocates and frees the basic context which carries through all of the
functions and callbacks in libSieve. At this time, the core parsers are not
thread-safe; B(only one instance may be allocated per-process).

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_callbacks)(C_TYPE(sieve2_context_t) *C_ARG(c), C_TYPE(sieve2_callback_t) *C_ARG(callbacks));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_listextensions)(C_TYPE(sieve2_context_t) *C_ARG(c));
	)

P	Registers a table of callbacks. See the structures page for details.
After a table of callbacks is registered, the extensions for which callbacks
have been registered will be listed by sieve2_listextensions.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_validate)(C_TYPE(sieve2_action_t) *C_ARG(c), C_TYPE(void) *C_ARG(user_data));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_execute)(C_TYPE(sieve2_action_t) *C_ARG(c), C_TYPE(void) *C_ARG(user_data));
	)

P	Validate a script and execute a script over a message. Validation will
only call the getscript callback, while execution will call getscript and
either getallheaders or getheader, then call the appropriate action callbacks.
The user_data you provide here will be passed into each of the callbacks.

P	The way to use this is to set up your own structure which contains
information the script and message you are currently working with. As the
callbacks are called, your functions, which know about your structure, can
figure out what they should be doing.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_getvalue_int)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_getvalue_string)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) * C_QUAL(const) C_FUNC(sieve2_getvalue_stringlist)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name));
	)

P	The getvalue family of functions allow you to retrieve information
about the callback being called. All of the memory returned by these
functions are managed by libSieve and will be freed by calling sieve2_free.

P	See the structures page for a listing of value names available to each
callback.

CODE	(
NO	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_int)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name), C_TYPE(int) C_ARG(value));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_string)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(name), C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_ARG(value));
BR	C_QUAL(extern) C_TYPE(int) C_FUNC(sieve2_setvalue_stringlist)(C_TYPE(sieve2_context_t) *C_ARG(c), C_QUAL(const) C_TYPE( char) * C_QUAL(const) C_ARG(name), C_QUAL(const) C_TYPE(char) * C_QUAL(const) * C_QUAL(const) C_ARG(value));
	)

P	The setvalue family of functions allows you to return values into
libSieve from your callbacks. This is your memory, and must be freed after
calling sieve2_free.

P	See the structures page for a listing of value names available to each
callback.

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_errstr)(C_QUAL(const) C_TYPE(int) C_ARG(code));
	)
P	Convert an error code to a generic description of the error.
Detailed error reports are found in the sieve2_error array. Do not free the
returned string, it is static.

CODE	(
NO	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_credits)(C_TYPE(void));
BR	C_QUAL(extern) C_QUAL(const) C_TYPE(char) * C_QUAL(const) C_FUNC(sieve2_license)(C_TYPE(void));
	)
P Get a list of Credits about who writes libSieve
and a brief rundown on the License under which
libSieve is distributed. Do not free the returned string, it is static.

ENDOFPRE
 	) ) );

 $smarty->assign( 'righttitle', 'notes.' );
 $smarty->assign( 'rightcontent', array(
 	array(
	<<<ENDOFPRE
The Sieve 2 API is an extensible API designed to ride through revisions
in the underlying implementation and through updates to the Sieve RFC
and various extensions, as they move from drafts towards full RFC&#39;s.

The API has three main parts: the incomplete opaque internal types, the
complete and user accessible external structures and the function calls.
ENDOFPRE
	) ) );
 $smarty->assign( 'rightlinks', array(
 	array( 'API Functions', 'functions.php' ),
 	array( 'API Structures', 'structures.php' ),
 	array( 'Example App', 'example.php' ),
	) );

 $smarty->display( 'tweedy.tpl' );

?>
